#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$'\n\t'

VERSION="1.0.1"
FORCE_KILL=false
VERBOSE=false

log() { $VERBOSE && printf '[wipe-bash-history] %s\n' "$*" >&2 || true; }
die() { printf '[wipe-bash-history] ERROR: %s\n' "$*" >&2; exit 1; }

while [[ $# -gt 0 ]]; do
  case "$1" in
    --force-terminate-sessions) FORCE_KILL=true ;;
    --skip-terminate-sessions)  FORCE_KILL=false ;;
    --verbose|-v)               VERBOSE=true ;;
    --version)                  echo "$VERSION"; exit 0 ;;
    *) die "Option inconnue: $1" ;;
  esac
  shift
done

[[ ${EUID:-$(id -u)} -eq 0 ]] || die "doit être exécuté en root"

if [[ -n "${BASH_VERSION-}" ]]; then
  export HISTFILE=/dev/null HISTSIZE=0 HISTFILESIZE=0 HISTCONTROL=ignorespace:ignoredups
  history -c || true
  history -w /dev/null || true
fi

if $FORCE_KILL; then
  if command -v loginctl >/dev/null 2>&1; then
    while read -r uid; do
      u=$(getent passwd "$uid" | cut -d: -f1 || true)
      [[ -n "$u" ]] && loginctl terminate-user "$u" >/dev/null 2>&1 || true
    done < <(ps -eo uid,comm,tty --no-headers | awk '$2=="bash" && $3!~/^\?$/ {print $1}' | sort -u)
    sleep 1
  fi
  pkill -TERM -x bash 2>/dev/null || true
  sleep 1
  pkill -KILL -x bash 2>/dev/null || true
fi

declare -a targets=()

while IFS=: read -r _ _ _ _ _ home shell; do
  [[ -d "$home" ]] || continue
  [[ "$shell" == *bash ]] || continue
  fs=$(stat -f -c %T "$home" 2>/dev/null || echo unknown)
  case "$fs" in
    proc|sysfs|tmpfs|devpts|cgroup2|autofs|squashfs|overlay|ramfs|bpf|tracefs|pstore|securityfs|nsfs)
      continue ;;
  esac
  targets+=( "$home/.bash_history" "$home/.bash_history~" "$home/.bash_history.old" )
done < <(getent passwd)

targets+=( "/root/.bash_history" "/etc/skel/.bash_history" )

purge_one() {
  local path="$1"
  local real="$path"
  if real=$(readlink -f -- "$path" 2>/dev/null); then
    path="$real"
  fi

  local parent
  parent=$(dirname -- "$path")
  if ! [[ -d "$parent" ]]; then
    return 0
  fi
  fs=$(stat -f -c %T "$parent" 2>/dev/null || echo unknown)
  case "$fs" in proc|sysfs|tmpfs|devpts|cgroup2|autofs|squashfs|overlay|ramfs|bpf|tracefs|pstore|securityfs|nsfs) return 0;; esac

  if [[ ! -e "$path" ]]; then
    owner=$(stat -c '%u' "$parent" 2>/dev/null || echo 0)
    group=$(stat -c '%g' "$parent" 2>/dev/null || echo 0)
    install -D -o "$owner" -g "$group" -m 600 /dev/null "$path" 2>/dev/null || return 0
  fi

  if command -v lsattr >/dev/null 2>&1 && command -v chattr >/dev/null 2>&1; then
    if lsattr -d "$path" 2>/dev/null | awk '{print $1}' | grep -q 'i'; then
      chattr -i "$path" 2>/dev/null || true
    fi
  fi

  command -v truncate >/dev/null 2>&1 \
    && truncate -s 0 -- "$path" 2>/dev/null || : 
  chmod 600 "$path" 2>/dev/null || :
}

printf '%s\n' "${targets[@]}" \
  | sed '/^$/d' | awk '!seen[$0]++' | sort -u \
  | while IFS= read -r f; do
      log "purge: $f"
      purge_one "$f"
    done

sync || true
